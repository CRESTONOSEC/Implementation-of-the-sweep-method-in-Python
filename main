# Функция для ввода матрицы с клавиатуры
def input_matrix(size):
    matrix = []  # Создаем пустой список для хранения матрицы.
    print(f"Введите матрицу размером {size}x{size}:")  # Печатаем сообщение с запросом ввода матрицы.
    for i in range(size):
        row = list(map(float, input(f"Введите элементы строки {i + 1} через пробел: ").split()))
        # Читаем строку, разделяем по пробелам и преобразуем каждый элемент в float.
        if len(row) != size:  # Проверяем, соответствует ли длина строки размеру матрицы.
            raise ValueError("Некорректный ввод: строка должна содержать столько же элементов, сколько указано в размере.")
            # Если длина строки неверная, вызываем ошибку.
        matrix.append(row)  # Добавляем строку в матрицу.
    return matrix  # Возвращаем введенную матрицу.

# Функция для ввода вектора с клавиатуры
def input_vector(size):
    print(f"Введите вектор размером {size}:")  # Печатаем сообщение с запросом ввода вектора.
    vector = list(map(float, input(f"Введите элементы правой части через пробел: ").split()))
    # Читаем строку, разделяем по пробелам и преобразуем каждый элемент в float.
    if len(vector) != size:  # Проверяем, соответствует ли длина вектора размеру.
        raise ValueError("Некорректный ввод: вектор должен содержать столько же элементов, сколько указано в размере.")
        # Если длина вектора неверная, вызываем ошибку.
    return vector  # Возвращаем введенный вектор.

# Функция для проверки, является ли матрица трёхдиагональной
def is_tridiagonal(matrix):
    num_rows = len(matrix)  # Определяем количество строк в матрице.
    num_cols = len(matrix[0])  # Определяем количество столбцов в матрице.

    if num_rows != num_cols:  # Проверяем, является ли матрица квадратной.
        return False  # Если нет, возвращаем False.

    for i in range(num_rows):
        for j in range(num_cols):
            if abs(i - j) > 1 and matrix[i][j] != 0:
                # Проверяем, если элемент не находится на главной или соседней диагонали и не равен нулю.
                return False  # Если это так, возвращаем False.

    return True  # Если все проверки пройдены, возвращаем True.

# Функция для вывода массива на экран
def print_arr(string, namevec, a):
    if (type(a) == int) or (type(a) == float):  # Проверяем, является ли a числом.
        print(a)  # Если да, просто выводим его.
    else:
        print(string)  # Выводим строку-описание.
        for k in range(len(a)):
            z = round(a[k], 4)  # Округляем элемент до 4 знаков после запятой.
            print(f"{namevec}[{k+1}] = {z}")

# Функция для проверки корректности 3х-диагональной матрицы коэффициентов
def isCorrectArray(a):
    n = len(a)  # Определяем размер матрицы.

    for row in range(0, n):
        if len(a[row]) != n:  # Проверяем, является ли длина строки равной размеру матрицы.
            print('Не соответствует размерность')  # Если нет, выводим сообщение об ошибке.
            return False  # Возвращаем False.

    for row in range(1, n - 1):
        if abs(a[row][row]) < abs(a[row][row - 1]) + abs(a[row][row + 1]):
            # Проверяем достаточные условия диагонального преобладания.
            print('Не выполнены условия достаточности')  # Если условия не выполнены, выводим сообщение.
            return False  # Возвращаем False.

    if (abs(a[0][0]) < abs(a[0][1])) or (abs(a[n - 1][n - 1]) < abs(a[n - 1][n - 2])):
        # Проверяем условия для первой и последней строки.
        print('Не выполнены условия достаточности')  # Если условия не выполнены, выводим сообщение.
        return False  # Возвращаем False.

    for row in range(0, len(a)):
        if a[row][row] == 0:  # Проверяем, есть ли нулевые элементы на главной диагонали.
            print('Нулевые элементы на главной диагонали')  # Если есть, выводим сообщение.
            return False  # Возвращаем False.

    return True  # Если все проверки пройдены, возвращаем True.

# Процедура нахождения решения 3-х диагональной матрицы
def solution(a, b):
    if not isCorrectArray(a):  # Проверяем корректность введенной матрицы.
        print('Ошибка в исходных данных')  # Если матрица некорректна, выводим сообщение.
        return -1  # Возвращаем -1, что указывает на ошибку.

    n = size  # Определяем размер матрицы.
    x = [0 for k in range(0, n)]  # Создаем вектор решений, заполненный нулями.

    # Прямой ход
    v = [0 for k in range(0, n)]  # Создаем вектор прогоночных коэффициентов v.
    u = [0 for k in range(0, n)]  # Создаем вектор прогоночных коэффициентов u.
    # для первой 0-й строки
    v[0] = a[0][1] / (-a[0][0])  # Вычисляем первый коэффициент v.
    u[0] = (-b[0]) / (-a[0][0])  # Вычисляем первый коэффициент u.
    for i in range(1, n - 1):
        v[i] = a[i][i + 1] / (-a[i][i] - a[i][i - 1] * v[i - 1])
        # Вычисляем текущий коэффициент v.
        u[i] = (a[i][i - 1] * u[i - 1] - b[i]) / (-a[i][i] - a[i][i - 1] * v[i - 1])
        # Вычисляем текущий коэффициент u.
    # для последней (n-1)-й строки
    v[n - 1] = 0  # Последний элемент v равен нулю.
    u[n - 1] = (a[n - 1][n - 2] * u[n - 2] - b[n - 1]) / (-a[n - 1][n - 1] - a[n - 1][n - 2] * v[n - 2])
    # Вычисляем последний коэффициент u.

    print_arr('Прогоночные коэффициенты v: ', 'v', v)  # Выводим прогоночные коэффициенты v.
    print_arr('Прогоночные коэффициенты u: ', 'u', u)  # Выводим прогоночные коэффициенты u.

    # Обратный ход
    x[n - 1] = u[n - 1]  # Последний элемент вектора решений равен последнему элементу u.
    for i in range(n - 1, 0, -1):  # Проходим в обратном порядке по строкам
        x[i - 1] = v[i - 1] * x[i] + u[i - 1]  # Вычисляем каждый элемент вектора решений.

    return x  # Возвращаем вектор решений.


size = int(input("Введите размер матрицы: "))  # Читаем размер матрицы.
a = input_matrix(size)  # Вводим матрицу.
b = input_vector(size)  # Вводим вектор.

print("Трехдиагональная ли матрица а?", is_tridiagonal(a))  # Проверяем, является ли матрица трехдиагональной.
x = solution(a, b)
print_arr('Решение: ', 'x', x)
